# memo

ゼロから学ぶRustを読み、学んだことをメモしていく。

## 2章 Rustの基本

真偽値型について、短絡評価と非短絡評価という二つがあることを知らなかった。

```Rust
A || B; // 短絡評価:Aが条件を満たさなかった時点でBの評価は行わない
A | B;  // 非短絡評価:Aが条件を満たしていない場合でも、Bも評価を行う
```

Rustにおける参照型とポインタ型の一番大きな違いは、ライフタイムによって保護されているか否かという部分にある。この本では、ポインタ型`*mut`などについては説明していない。

### 配列とスライス

配列はメモリ上の連続した場所に格納されている要素の集合のこと。スライスは、メモリ上の連続した値への参照であり、内部的にはポインタと要素数を保持する。

```Rust
let arr: [u32; 4] = [1, 2, 3, 4];
println!("{}, {}, {}, { }", arr[0], arr[1], arr[2], arr[3]);

let s: &[u32] = &arr[1..3] // index1-2の要素をスライスとして取得
println!("{:?}", s) // [2, 3]を出力
```

### ユーザ定義型

**列挙型: enum**
いくつかの値を取りうる際に、その集合をenum型として定義する。

```Rust
enum DoW {
  Sunday,
  Monday,
  Tuesday,
  Wednesday,
  Thursday,
  Friday,
  Saturday,
}

let day: DoW::Tuesday;
```

### ジェネリクス

ジェネリクスには、大きく二つの種類が存在する。

- ジェネリック型: **型**を返す
- ジェネリック関数: **関数**を返す

```Rust
enum List<T> { // (1)
  Node { data: T, next: Box<List<T>>}, // (2)
  Nil,
}

let n1 = List::<u32>::Nil; // (3)
let n2 = List::<u32>::Node { // (4)
  data: 10,
  next: Box::<List<u32>>::new(n1),
}

let n3 = List::Node { // (5)
  data: 40,
  next: Box::<List<u32>>::new(n1),
}
```

- 実装の説明

(1) Tがジェネリック型の引数であり、ここに型や定数を渡すことができる。
(2) `Box`はジェネリック型であり、`List<T>`を引数として、具体的なBox型を得る。
(3) `List<T>`に対して具体的な型を渡している。この例のように`::<>`を利用する。
(4) `List<u32>`のNodeという値を生成する。
(5) (4)とほぼ同等だが、コンパイラの型推論に任せて一部の宣言を省略している。

**重要なジェネリック型**
Option型とResult型がある。

```Rust
enum Option<T> {
  Some(T),
  None,
}
enum Result<T, E> {
  Ok(T),
  Err(E),
}
```

これらのジェネリック型は失敗する可能性のある関数の返り値として利用される。関数の実行に成功した場合は、SomeやOkに値を包んで返し、失敗した場合はNoneかErrを返す。

### クロージャ(closure)

名前のない関数のこと。Rustでは、クロージャを[|引数|式]という構文で定義する。例えば、加算を実行するクロージャは以下のように書ける。

```Rust
let f = |a, b| a + b;
let n = f(a, b);
```

### unsafe

`unsafe`を利用すると型システムの保護から解放され、プログラマの責任で安全性を担保する必要のあるコードを実装する必要がある。
この機能を利用するのは、主に以下の二つの場面

1. HWやOS、あるいはRust以外の言語で書かれたソフトウェアとの連携などとの連携など、Rustの外の関数を呼び出したりデータをやりとりする場面
2. Rustの型システムの制約上、記述が難しいアルゴリズムを実装する場面

### thread

プログラムの実行単位であるthreadは、`swawn`と`join`を利用して管理を行う。基本的にswawnで生成してjoinで終了を待つイメージとなる。また、スレッド間でデータをやり取りするためにはチャネルという抽象的な通信路を利用する。

## 3章 所有権・ライフタイム・借用

Rustでは、関数呼び出しやmatch式、代入などで変数を利用すると変数は消費される。関数呼び出しや代入の場合、消費された変数は関数内や代入先の変数に所有権が移動する。このような動作を**move semantics**と呼ぶ.
ライフタイムとは、その名の通り変数が有効な期間のことを示す言葉である。
ある変数の参照を得ることを特別に**借用**と表現する。
