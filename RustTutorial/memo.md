# The Rust Programming Language

[公式ドキュメント](https://doc.rust-jp.rs/book-ja/)を読み、理解した内容について記録していく。

## 開発環境

vscode上で色々試していくので、今回はdevcontainer上にMS公式のRustイメージを利用して色々試すことにした。

## メモ

- Rustはデフォルトで変数がimmutable(不変)。可変変数として定義したい場合は、名義的に`mut`とする必要がある。
- シャドーイング: すでに変数として定義されているものを覆い隠す形で新規変数を定義すること。
- Rustの型: スカラー型(数値と文字列型)と複合型が存在する
  - 複合型: tupleとは配列が存在する。違いは、tupleは要素の型の違いを許容し、配列は許容しない点。
- Rustにおける式と文の違い
  - 変数定義や関数の変数と言ったようなものを定義したい場合は、文末に`;`をつけることはしない。これは、セミコロンをつけることによって式ではなく文としてRustコンパイラに認識されてしまうためである。
- 多重loop処理を定義する場合、loopにラベルを付与することで、条件に応じたloopを終了させることができる。
- 構造体: タプルと同様異なる複数の型をひとまとめに定義することができる。タプルとの大きな違いは、各データに対して名前を付与することができるので、より値の意味を明確にしたプログラミングを行うことができる。
  - 定義された構造体の一部の要素を変更したい要件がある場合は、構造体全体を`mut`として定義する必要がある。また、関数の帰り値として構造体インスタンスを指定することもできる。

### 所有権

Rustの一番特徴的に重要なルール

- Rustの値は所有者と呼ばれる変数と対応している。
- いかなる時も所有者は一つである。
- 所有者がスコープから外れたら、値は破棄される。

ソースに記載された文字列リテラルはコンパイル時に中身が判明しているので、バイナリファイル内にハードコードされる->早い
String型では、可変であるテキストスタイルであるので、コンパイル時には確保すべきメモリ量や文字列をハードコードすることができない。そのため、ヒープに確保して使用し終わったらヒープメモリを解放する必要がある。Cなどでは`allocate`と`free`がこの概念に対応する操作であるが、Rustではここに関して別のアプローチをしている。

```Rust
{
let s = String::from("Hello"); // 変数sはここからメモリ上に確保される

// この辺りでもsは有効
} // sを含めたスコープはここまで,sは有効ではないものになる。
```

むず、、stringの変数を定義する場合は基本的に何もしないと実際の値がメモリ上のどこに確保されているかを示す情報のみがコピーされる。そのため、関数などでstring型のスコープを抜ける処理を実装してしまうと、メモリの所有者がスコープから外れヒープメモリ上に値を確保しなくなってしまう。これに対処するためには、関数の引数与える際にちゃんと`clone()`しないといけない
とりあえず覚えておかないといけないのは、所有権が外れるようなスカラー以外の値を活用する場合は、スコープを外れてしまうかどうかをちゃんと意識すること。

この点は関数に対して参照渡しをすることで解決することができる。参照渡しとは、引数にstringのクローンやアドレス参照値を渡すのではなく、string側の参照情報が格納されているアドレス自体を参照する方法。これによって、スコープから外れる際に所有権を失うのはあくまで参照情報に対す参照で、元々の値が破棄されることはなくなる。以下はサンプルコード

```Rust
fn main() {
    let s1 = String::from("hello world");
    let len = calculate_length(&s1); // s1への参照を引数として渡している

    println!("The length of {} is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {//この関数に対して与えられるのは、String型の値を差し示す参照情報であり、元々の値(今回の例ではs1)ではない
    s.len()
}//スコープから外れた時点でs、すなわちs1に対する参照の所有権が失われ、値が破棄される。
```

### Enum

enumは列挙型とも呼ばれ、取りうる値を全て列挙し定義できるもの。
例)IPアドレスはIPv4とIPv6の二つのバージョンが存在し、両方とも満たす状態は存在しない。このような場合にenumデータ構造は有意に働く。実際のコードは以下のように定義する。

```Rust
enum IPAddrKind {
  V4,
  V6,
}

let four = IPAddrKind::V4;
let six = IPAddrKind::V6;
```

基本的に構造体でも同じことはできるけど、列挙したものそれぞれに対して同じメソッドを定義したい場合は、enumの方がはるかに便利そう。

match型はどうやって使うのだろうと思っていたが、enumと組み合わせると便利なのか。

### 肥大化するパッケージ管理

crate root: Rustコンパイラの基準点として、クレートのルートモジュールを作るソースファイルのこと。cargo new my_projectで新規プロジェクトを開始した場合は、src/main.rsがクレートルートであるという慣習にしたがっている。ここにlib.rsをおけばライブラリクレートだと判断する。
このようにcargoはクレートルートファイルをrustcに渡して、ライブラリやバイナリをビルドする。

モジュール: クレート内のコードをグループ化して、可読性と再利用性を上げることができる。
`src/main.rs`や`src/lib.rs`をクレートルートと呼ぶことを説明されたが、これはモジュール構造のルートにこの二つのファイルがcrateというモジュールを形成するため。以下にサンプルコードとそのモジュールツリーを表示する。

```Rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
        fn seat_at_table() {}
    }

    mod serving {
        fn take_order() {}
        fn serve_order() {}
        fn take_payment() {}
    }
}
```

```module tree
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

この例はlib.rsを例に挙げたが、main.rsの場合も、その内部で関数やstructなどツリー構造を形成する個別の要素が存在する。

### コレクション

ベクタ型`Vec<T>`: 同じ型の値を保持する。リストとして利用することが多い。
定義は以下のようにして実装する:

```Rust
let v:: Vec<i32> = Vec::new();
let v = vec![1, 2, 3] # マクロを利用した定義
```

ベクタ要素を参照する方法は二つ。添字を指定する方法とgetメソッドを利用する方法。もし、ベクタ外の値を指定して実行すると
&vec[100] -> panic
v.get(100) -> None
と結果が異なる。終端を超えてアクセスする可能性がある場合はgetメソッドを利用する方法の方がよりエラーハンドリングを行いやすい。

### エラー処理

Rustで発生するエラーには、回復可能なものと回復不可能なものが存在する。それぞれについて考える。

- 回復不能: panic!
回復不能なエラーが発生した場合は、`panic!`マクロを使用して、スタックを巻き戻して終了する。

### ジェネリック型・トレイト

プログラミングでは、重複した概念を効率的に扱うツールや実装が存在する。Rustでは、**ジェネリクス**がその一例となる。
ジェネリクスは簡単にいうと、コンパイル時にはジェネリクスの位置に何が格納されるのかをコンパイラ側が知らず、実行される時に初めて決定されるようなもののことを指す。ここまでにも`Option><T>`や`vec<T>`と言った形で利用してきている。

### 自動テスト

### 関数型言語の機能

クロージャ：変数に保存したり、引数として他の関数に渡すことができる匿名関数。
